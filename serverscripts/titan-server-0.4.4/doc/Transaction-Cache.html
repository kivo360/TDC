<!DOCTYPE html>

<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Transaction Cache</title>
    <link rel="stylesheet" href="./css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="./css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="./css/syntax.css" type="text/css" charset="utf-8" />
    <script src="./javascript/jquery-1.4.2.min.js" type="text/javascript"></script>
    <script src="./javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="./javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="./javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="./javascript/gollum.js" type="text/javascript"></script>
  </head>

  <body>
    <div id="main">
      <div class="site">
        <div id="guides">
          <div class="guide">
            <div class="main">
              <div class="actions">
                <div>
                  <a href="./Home.html">Aurelius Titan</a>
                </div>
              </div>
              <h1>Transaction Cache</h1>
              <div class="content wikistyle gollum textile">
                <p>Titan maintains two caches within each open transaction: a vertex cache and an index cache. The size of both of those is determined by the <em>transaction cache size</em>. The transaction cache size can be configured via <code>tx-cache-size</code> or on a per transaction basis by opening a transaction via the transaction builder <code>graph.buildTransction()</code> and using the <code>setCacheSize(int)</code> method.</p>
<h2>Vertex Cache</h2>
<p>The vertex cache contains vertices and the subset of their adjacency list that has been retrieved in a particular transaction. The maximum number of vertices maintained in this cache is equal to the transaction cache size. If the transaction workload is an iterative traversal, the vertex cache will significantly speed it up. If the same vertex is not accessed again in the transaction, the transaction level cache will make no difference.</p>
<p>Note, that the size of the vertex cache on heap is not only determined by the number of vertices it may hold but also by the size of their adjacency list. In other words, vertices will large adjacency lists (i.e. many incident edges) will consume more space in this cache than those with smaller lists.</p>
<p>Furthermore note, that modified vertices are <em>pinned</em> in the cache, which means they cannot be evicted since that would entail loosing their changes. Therefore, transaction which contain a lot of modifications may end up with a larger than configured vertex cache.</p>
<h2>Index Cache</h2>
<p>The index cache contains the results of index queries executed in the context of this transaction. Subsequent identical index calls will be served from this cache and are therefore significantly cheaper. If the same index call never occurs twice in the same transaction, the index cache makes no difference.</p>
<p>Each entry in the index cache is given a weight equal to <code>2 + result set size</code> and the total weight of the cache will not exceed half of the transaction cache size.</p>
              </div>
            </div>
          </div>
          <div class="admin">
            <div style="float: left;">
              <small>Last edited by <b>Dan LaRocque</b>, 2014-04-22 09:02:35</small>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
