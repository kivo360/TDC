<!DOCTYPE html>

<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <title>Titan Data Model</title>
    <link rel="stylesheet" href="./css/screen.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="./css/gollum.css" type="text/css" charset="utf-8" />
    <link rel="stylesheet" href="./css/syntax.css" type="text/css" charset="utf-8" />
    <script src="./javascript/jquery-1.4.2.min.js" type="text/javascript"></script>
    <script src="./javascript/jquery.text_selection-1.0.0.min.js" type="text/javascript"></script>
    <script src="./javascript/jquery.previewable_comment_form.js" type="text/javascript"></script>
    <script src="./javascript/jquery.tabs.js" type="text/javascript"></script>
    <script src="./javascript/gollum.js" type="text/javascript"></script>
  </head>

  <body>
    <div id="main">
      <div class="site">
        <div id="guides">
          <div class="guide">
            <div class="main">
              <div class="actions">
                <div>
                  <a href="./Home.html">Aurelius Titan</a>
                </div>
              </div>
              <h1>Titan Data Model</h1>
              <div class="content wikistyle gollum textile">
                <p>Titan stores graphs in <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list format</a> which means that a graph is stored as a collection of vertices with their adjacency list. The adjacency list of a vertex contains all of the vertex’s incident edges (and properties).</p>
<p>By storing a graph in adjacency list format Titan ensures that all of a vertex’s incident edges and properties are stored compactly in the storage backend which speeds up traversals. The downside is that each edge has to be stored twice – once for each end vertex of the edge.</p>
<p>In addition, Titan maintains the adjacency list of each vertex in sort order with the order being defined by the <a class="internal present" href="./Type-Definition-Overview.html">sort-key configurations</a> of the edge labels. The sort order enables efficient retrievals of subsets of the adjacency list using <a class="internal present" href="./Vertex-Centric-Indices.html">vertex centric indices</a>.</p>
<p>Titan stores the adjacency list representation of a graph in any <a class="internal present" href="./Storage-Backend-Overview.html">storage backend</a> that supports the BigTable data model.</p>
<h2>BigTable Data Model</h2>
<p><span class="align-center"><span><img src="https://raw.github.com/thinkaurelius/titan/gh-pages/images/bigtablemodel.png" width="750px"></span></span></p>
<p>Under the <a href="http://en.wikipedia.org/wiki/Bigtable">BigTable data model</a> each table is a collection of rows. Each row is uniquely identified by a key. Each row is comprised of an arbitrary (large, but limited) number of cells. A cell is composed of a column and value. A cell is uniquely identified by a column within a given row. Rows in the BigTable model are called “wide rows” because they support a large number of cells and the columns of those cells don’t have to be defined up front as is required in relational databases.</p>
<p>Titan has an additional requirement for the BigTable data model: The cells must be sorted by their columns and a subset of the cells specified by a column range must be efficiently retrievable (e.g. by using index structures, skip lists, or binary search).</p>
<p>In addition, a particular BigTable implementation may keep the rows sorted in the order of their key. Titan can exploit such key-order to effectively partition the graph which provides better loading and traversal performance for very large graphs. However, this is not a requirement.</p>
<h2>Titan Data Layout</h2>
<p><span class="align-center"><span><img src="https://raw.github.com/thinkaurelius/titan/gh-pages/images/titanstoragelayout.png" width="750px"></span></span></p>
<p>Titan stores each adjacency list as a row in the underlying storage backend. The (64 bit) vertex id (which Titan uniquely assigns to every vertex) is the key which points to the row containing the vertex’s adjacency list. Each edge and property is stored as an individual cell in the row which allows for efficient insertions and deletions.<br>
The maximum number of cells allowed per row in a particular storage backend is therefore also the maximum degree of a vertex that Titan can support against this backend.</p>
<p>If the storage backend supports key-order, the adjacency lists will be ordered by the id of their vertex and Titan’s can assign vertex ids such that the graph is effectively partitioned. Ids are assigned such that vertices which are frequently co-accessed have ids with small absolute difference.</p>
<h2>Individual Edge Layout</h2>
<p><span class="align-center"><span><img src="https://raw.github.com/thinkaurelius/titan/gh-pages/images/relationlayout.png" width="650px"></span></span></p>
<p>Each edge and property is stored as one cell in the rows of its adjacent vertices. They are serialized such that the byte order of the column respects the sort key of the edge label. Variable id encoding schemes and compressed object serialization are used to keep the storage footprint of each edge/cell as small as possible.</p>
<p>Consider the storage layout of an individual edge as visualized in the top row of the graphic above. The dark blue boxes represent numbers that are encoded with a variable length encoding scheme to reduce the number of bytes they consume. Red boxes represent one or multiple property values (i.e. objects) that are serialized with compressed meta data referenced in the associated property key. Grey boxes represent uncompressed property values (i.e. serialized objects).</p>
<p>The serialized representation of an edge starts with the edge label’s unique id (as assigned by Titan). This is typically a small number and compressed well with variable id encoding. The last bit of this id is offset to store whether this is an incoming or outgoing edge. Next, the property value comprising the sort key are stored. The sort key is defined with the edge label and hence the sort key objects meta data can be referenced to the edge label. After that, the id of the adjacent vertex is stored. Titan does not store the actual vertex id but the difference to the id of the vertex that owns this adjacency list. It is likely that the difference is a smaller number than the absolute id and hence compresses better. The vertex id is followed by the id of this edge. Each edge is assigned a unique id by Titan. This concludes the column value of the edge’s cell. The value of the edge’s cell contains the compressed serialization of the signature properties of the edge (as defined by the label’s signature key) and any other properties that have been added to the edge in uncompressed serialization.</p>
<p>The serialized representation of a property is simpler and only contains the property’s key id in the column. The property id and the property value are stored in the value. If the property key is defined as <code>list()</code>, however, the property id is stored in the column as well.</p>
              </div>
            </div>
          </div>
          <div class="admin">
            <div style="float: left;">
              <small>Last edited by <b>Dan LaRocque</b>, 2014-04-22 09:02:35</small>
            </div>
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
